---
title: "[UniRx] UniRx 기록 1"
categories:
  - UniRx
tags:
  - UnityC#
  - UniRx
toc: true
toc_sticky: true
toc_label: "UniRx 기록 1"
toc_icon: "sticky-note"
---



# 참고 문헌

🔺 [UniRx入門 その1](https://qiita.com/toRisouP/items/2f1643e344c741dd94f8){:target="_blank"} 원본 링크. <br>
- <https://qiita.com/toRisouP/items/2f1643e344c741dd94f8> <br>

🔺 [UniRx 입문 1](https://tech.lonpeach.com/2019/11/03/UniRx-Getting-Started-1/){:target="_blank"} 원본 구글번역 링크. <br>
- <https://tech.lonpeach.com/2019/11/03/UniRx-Getting-Started-1/> <br>

🔺[UniRx/UniTask Observable.FromCoroutineをUniTaskで書く](https://qiita.com/toRisouP/items/0c09c6eaa23bb8e0b215){:target="_blank"} 저장용
- <https://qiita.com/toRisouP/items/0c09c6eaa23bb8e0b215> <br>

🔺[UniTask Ver2 、UniTaskAsyncEnumerableまとめ](https://qiita.com/toRisouP/items/8f66fd952eaffeaf3107){:target="_blank"} 저장용

# Observableとの使い分け

Observable은 Push 형이지만 UniTaskAsyncEnumerable은 Pull 형입니다. <br>
따라서 UniTaskAsyncEnumerable에서는 비동기 처리의 실행 타이밍을 수신측에서 제어할 수 있다는 장점이 있습니다. <br>

```cs
private async void Start()
{
    var token = this.GetCancellationTokenOnDestroy();

    var uris = new[]
    {
        "https://www.google.com/",
        "https://unity.com/ja",
        "https://github.com/"
    };


    // URI 목록에 액세스하여 데이터를 가져옵니다.
    // 그러나 항상 수행되는 통신은 동시에 하나이며,
    // 마지막으로 완료되지 않으면 다음 통신으로 진행되지 않습니다.
    await uris.ToUniTaskAsyncEnumerable()
        // 통신 완료를 기다리고 메시지 발행
        .SelectAwait(async x => await FetchAsync(x))
        .ForEachAsync(x => Debug.Log(x), token);
}


private async UniTask<string> FetchAsync(string uri)
{
    using (var uwr = UnityWebRequest.Get(uri))
    {
        await uwr.SendWebRequest();
        if (uwr.isNetworkError || uwr.isHttpError)
        {
            throw new Exception($"Error>{uwr.error}");
        }

        return uwr.downloadHandler.text;
    }
}
```


<script src="https://gist.github.com/ggm3414/ce2ad0fac3c15be80f36383536ee9129.js"></script>